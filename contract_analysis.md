# تحلیل قراردادهای هوشمند پروژه رای‌گیری

این گزارش به تحلیل و بررسی سه قرارداد هوشمند اصلی پروژه می‌پردازد که بر اساس استاندارد ERC-4337 برای ایجاد یک سیستم رای‌گیری بدون کارمزد (gasless) طراحی شده‌اند.

## معماری کلی سیستم

این پروژه از الگوی **Account Abstraction (ERC-4337)** بهره می‌برد تا تجربه کاربری رای‌دهندگان را بهبود بخشد. در این معماری:
1.  **کاربر (رای‌دهنده)**: یک `UserOperation` (عملیات کاربر) را امضا می‌کند که حاوی اطلاعات رای اوست.
2.  **Bundler**: این `UserOperation` را از یک ممپول (mempool) جداگانه برداشته و به قرارداد `EntryPoint` ارسال می‌کند.
3.  **EntryPoint**: یک قرارداد سراسری و استاندارد است که وظیفه هماهنگی بین قراردادهای `Paymaster` و `VoterAccount` را بر عهده دارد.
4.  **Paymaster**: قرارداد پرداخت‌کننده کارمزد است. این قرارداد بررسی می‌کند که آیا `UserOperation` مجاز است یا خیر و در صورت تایید، کارمزد تراکنش را تقبل می‌کند.
5.  **VoterAccount**: قرارداد کیف پول هوشمند مخصوص هر رای‌دهنده است که منطق اصلی اجرای رای را در خود جای داده و با قرارداد `TVoting` تعامل می‌کند.
6.  **TVoting**: قرارداد اصلی که منطق رای‌گیری، شمارش آرا و اعلام نتایج را پیاده‌سازی می‌کند.

---

## 1. قرارداد `TVoting.sol`

این قرارداد به عنوان صندوق رای دیجیتال عمل می‌کند.

### ویژگی‌های کلیدی:
- **مالکیت (Ownership)**: یک آدرس به عنوان `owner` تعریف می‌شود که اختیارات ویژه‌ای مانند شروع انتخابات و مشاهده نتایج را دارد.
- **راه‌اندازی انتخابات**: مالک قرارداد می‌تواند با ارائه لیستی از آدرس‌های رای‌دهندگان و تعداد رای هر کدام، انتخابات را آغاز کند.
- **فرآیند رای‌دهی**: رای‌دهندگان ثبت‌شده می‌توانند با فراخوانی تابع `vote`، رای خود را برای نامزدهای مختلف ثبت کنند. سیستم بررسی می‌کند که آیا رای‌دهنده به تعداد کافی رای دارد یا خیر.
- **مشاهده نتایج**: مالک قرارداد می‌تواند برنده انتخابات را با فراخوانی تابع `results` مشخص کند.

### توابع مهم:
- `constructor(uint8 _numOfCandidates)`: انتخابات را با تعداد مشخصی نامزد راه‌اندازی می‌کند.
- `startElection(address[] memory _voters, uint256[] memory _numOfVotes)`: لیست رای‌دهندگان مجاز و تعداد آرای تخصیص‌یافته به آن‌ها را تنظیم می‌کند (فقط توسط `owner`).
- `vote(uint256[] memory _candidates)`: به یک رای‌دهنده ثبت‌شده اجازه می‌دهد تا رای خود را ثبت کند.
- `results()`: نامزد پیروز را بر اساس بیشترین تعداد رای برمی‌گرداند (فقط توسط `owner`).

---

## 2. قرارداد `VoterAccount.sol`

این یک کیف پول هوشمند (Smart Contract Wallet) برای هر رای‌دهنده است که بر اساس استاندارد ERC-4337 پیاده‌سازی شده است.

### ویژگی‌های کلیدی:
- **Account Abstraction**: به رای‌دهندگان اجازه می‌دهد بدون نیاز به مدیریت مستقیم کارمزد (gas)، با سیستم تعامل کنند.
- **نقطه ورود (EntryPoint)**: با یک قرارداد `EntryPoint` استاندارد تعامل می‌کند.
- **اعتبارسنجی عملیات**: `UserOperation` ها را از طریق تابع `validateUserOp` اعتبارسنجی می‌کند. نکته جالب در این پیاده‌سازی این است که امضای تمام عملیات باید توسط یک آدرس متمرکز به نام `i_rayshomarAddress` انجام شود. این ممکن است یک مکانیزم کنترلی یا یک لایه انتزاعی برای احراز هویت متمرکز باشد.
- **اجرای رای**: پس از اعتبارسنجی موفق، تابع `execute` را فراخوانی کرده و از طریق آن، تابع `vote` را در قرارداد `TVoting` اجرا می‌کند.

### توابع مهم:
- `validateUserOp(...)`: عملیات کاربر را تایید می‌کند. این تابع بررسی می‌کند که آیا امضای عملیات متعلق به `i_rayshomarAddress` است یا خیر.
- `execute(uint256[] calldata _candidates)`: تابع `vote` را در قرارداد `TVoting` فراخوانی می‌کند.
- `setForNewElection(address _rayshomarAddress, address _tVoting)`: آدرس `rayshomar` و آدرس قرارداد `TVoting` را برای یک انتخابات جدید تنظیم می‌کند.

---

## 3. قرارداد `Paymaster.sol`

این قرارداد کارمزد تراکنش‌های رای‌دهندگان را پرداخت می‌کند و به عنوان حامی مالی (sponsor) عمل می‌کند.

### ویژگی‌های کلیدی:
- **پرداخت کارمزد (Gas Sponsoring)**: در صورت موفقیت‌آمیز بودن اعتبارسنجی، هزینه گس `UserOperation` را پرداخت می‌کند.
- **تایید رای‌دهنده با Merkle Tree**: برای تایید اینکه آیا یک رای‌دهنده مجاز است یا خیر، از درخت مرکل (Merkle Tree) استفاده می‌کند. ریشه (Merkle Root) این درخت در زمان استقرار قرارداد تنظیم می‌شود. این روش یک راهکار بهینه و مقیاس‌پذیر برای مدیریت لیست سفید (whitelist) کاربران است.
- **اعتبارسنجی**: تابع `validatePaymasterUserOp` یک Merkle Proof را از فیلد `paymasterAndData` در `UserOperation` استخراج کرده و با ریشه درخت مقایسه می‌کند.

### توابع مهم:
- `constructor(address _entryPoint, bytes32 _merkleRoot)`: آدرس `EntryPoint` و ریشه درخت مرکل رای‌دهندگان را تنظیم می‌کند.
- `validatePaymasterUserOp(...)`: بررسی می‌کند که آیا `Paymaster` باید هزینه تراکنش را بپردازد یا خیر. این کار را با تایید Merkle Proof انجام می‌دهد.
- `_checkVoter(address voterAddress, bytes32[] memory merkleProof)`: صحت Merkle Proof را در برابر Merkle Root ذخیره‌شده بررسی می‌کند.
- `_getMerkleProof(bytes memory paymasterAndData)`: اطلاعات Merkle Proof را از داده‌های `UserOperation` استخراج می‌کند.

## جمع‌بندی

این سیستم یک نمونه پیشرفته و هوشمندانه از کاربرد Account Abstraction در دنیای واقعی است. استفاده از **Merkle Tree** در `Paymaster` برای مدیریت بهینه لیست رای‌دهندگان و طراحی **VoterAccount** به عنوان یک کیف پول هوشمند، نشان‌دهنده درک عمیق طراحان از قابلیت‌های بلاکچین است.

تنها نکته قابل تامل، وابستگی به یک امضای متمرکز (`i_rayshomarAddress`) در `VoterAccount` است که می‌تواند نقطه ضعف بالقوه‌ای از نظر تمرکززدایی باشد، هرچند ممکن است این طراحی برای اهداف خاصی (مانند کنترل دسترسی در یک محیط خصوصی) انجام شده باشد.
